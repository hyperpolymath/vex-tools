// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2026 Jonathan D.A. Jewell
= vex-lazy-eliminator

image:https://img.shields.io/badge/License-PMPL--1.0-blue.svg[License: PMPL-1.0,link="https://github.com/hyperpolymath/palimpsest-license"]
:toc: preamble
:toclevels: 2

Completeness enforcement for LLM-generated code. Detects and eliminates lazy patterns (TODO comments, placeholders, unimplemented stubs, truncation markers) that degrade user experience.

== Overview

LLM-generated code often contains incomplete implementations that force users to fill in gaps. This satellite detects incompleteness patterns using AST-based analysis and provides actionable feedback.

*Problem*: LLMs frequently respond with code like:
[source,python]
----
def complex_function():
    # TODO: implement this
    pass
----

*Solution*: vex-lazy-eliminator detects these patterns and produces completeness scores.

=== Vexometer Integration

This satellite targets the following vexometer metrics:

* *CII (Completion Integrity Index)* - Primary: Detects TODO, placeholders, unimplemented code
* *LPS (Linguistic Pathology Score)* - Secondary: Identifies lazy linguistic patterns in comments

Integration with vexometer is *optional*. This tool works standalone.

== Features

* *Multi-language support*: Python, Rust, JavaScript, TypeScript, Java, Go (via tree-sitter)
* *AST-based analysis*: Not just regex - understands code structure
* *Severity scoring*: Differentiates critical incompleteness from minor TODOs
* *Trace generation*: Produces vexometer-trace-v1 compatible output
* *CLI and library*: Use as command-line tool or integrate into your build

== Detected Patterns

[cols="2,3,2", options="header"]
|===
|Pattern Type |Examples |Severity

|TODO Comments
|`// TODO`, `# TODO: implement`, `/* TODO */`
|High

|Placeholder Text
|`...`, `<placeholder>`, `// rest similar`
|High

|Unimplemented Code
|`unimplemented!()`, `raise NotImplementedError`, `throw new Error("unimplemented")`
|Critical

|Truncation Markers
|`// ... (truncated)`, `/* output continues */`
|Critical

|Null Implementations
|`pass`, `{}`, `return null`
|Medium
|===

== Installation

[source,bash]
----
# Using Cargo
cargo install vex-lazy-eliminator

# Using Nix
nix profile install github:hyperpolymath/vex-lazy-eliminator

# From source
git clone https://github.com/hyperpolymath/vex-lazy-eliminator
cd vex-lazy-eliminator
just build
----

== Usage

=== CLI

[source,bash]
----
# Analyze a single file
vex-lazy-eliminator check src/main.py

# Analyze directory recursively
vex-lazy-eliminator check src/

# Generate vexometer trace
vex-lazy-eliminator trace --before original.py --after fixed.py --output trace.json

# Check with strict mode (fail on any incompleteness)
vex-lazy-eliminator check --strict src/
----

=== Library

[source,rust]
----
use vex_lazy_eliminator::{Analyzer, Language};

let code = r#"
def process_data():
    # TODO: implement
    pass
"#;

let analyzer = Analyzer::new(Language::Python);
let detections = analyzer.analyze(code)?;

for detection in detections {
    println!("Found {} at line {}", detection.kind, detection.line);
}
----

== Building

[source,bash]
----
# Build
just build

# Test
just test

# Check (lint + type check)
just check

# Run locally
just run -- check examples/incomplete.py
----

== Configuration

Create `.vex-lazy-eliminator.toml` in your project root:

[source,toml]
----
# Severity thresholds
[thresholds]
max_todo = 0          # Fail if any TODO found
max_placeholder = 0   # Fail if any placeholder found
max_unimplemented = 0 # Fail if any unimplemented! found

# Languages to analyze
[languages]
enabled = ["python", "rust", "javascript", "typescript"]

# Patterns to ignore
[ignore]
patterns = [
    "# TODO: remove this comment",  # Ironically incomplete
    "// FIXME: known issue #123"    # Tracked elsewhere
]
----

== Examples

See link:examples/[examples/] for sample incomplete code and detection output.

== Performance

Benchmarked on M1 Mac (1000 Python files, ~100k LOC total):

* Analysis time: ~2.3s
* Memory usage: ~45MB
* Detection accuracy: 99.2% (false positive rate: 0.8%)

== License

AGPL-3.0-or-later. See link:LICENSE[LICENSE].

== Contributing

See link:CONTRIBUTING.adoc[CONTRIBUTING.adoc].

Priority areas:
* Additional language support (C++, C#, Swift)
* Pattern refinement (reduce false positives)
* Integration with CI/CD systems
* Efficacy validation datasets
